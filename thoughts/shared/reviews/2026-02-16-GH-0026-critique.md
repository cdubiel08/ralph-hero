---
date: 2026-02-16
github_issue: 26
github_url: https://github.com/cdubiel08/ralph-hero/issues/26
plan_document: thoughts/shared/plans/2026-02-16-GH-0026-workflow-visualization-pipeline-dashboard.md
status: approved
type: critique
---

# Plan Critique: GH-26 Workflow Visualization and Pipeline Status Dashboard

## Verdict: APPROVED with Warnings

The plan is well-structured, feasible, and implementable. The 3-phase approach with pure function extraction (lib/dashboard.ts) is a strong architectural choice that enables thorough testing without mocking. All referenced infrastructure exists. No blocking issues found, but several warnings require implementer attention.

## Verified Claims

| Claim | Plan Reference | Actual | Status |
|-------|---------------|--------|--------|
| `list_project_items` at lines 379-583 | Current State table | Tool registration starts at line 378, tool handler ends at line 549. Lines 552-583 are internal helpers (`RawProjectItem`, `getFieldValue`). The range is reasonable if interpreted as "the tool plus its helpers". | CLOSE ENOUGH |
| `STATE_ORDER` at lines 12-22 | Current State table | Confirmed: lines 12-22 with 9 ordered states | EXACT |
| `LOCK_STATES` exists | Current State table | Confirmed: lines 32-36, 3 states | EXACT |
| `TERMINAL_STATES` exists | Current State table | Confirmed: line 27, ["Done", "Canceled"] | EXACT |
| `HUMAN_STATES` exists | Current State table | Confirmed: lines 41-44, ["Human Needed", "Plan in Review"] | EXACT |
| `VALID_STATES` exists | Current State table | Confirmed: lines 49-53, spread of STATE_ORDER + Canceled + Human Needed | EXACT |
| `stateIndex()`, `compareStates()`, `isEarlierState()` exist | Research doc | Confirmed: lines 60-81 | EXACT |
| `paginateConnection` exists | Current State table | Confirmed: pagination.ts lines 65-119 | EXACT |
| `SessionCache` exists | Current State table | Confirmed: cache.ts lines 14-89 | EXACT |
| `FieldOptionCache` exists | Current State table | Confirmed: cache.ts lines 100-189 | EXACT |
| Tool registration pattern | Phase 2 Step 3 | 4 groups registered in index.ts: core, project, view, issue, relationship (lines 284-294) | EXACT |
| `toolSuccess()` / `toolError()` exist | Phase 2 Step 2 | Confirmed: types.ts lines 246-257 | EXACT |
| `ConvergenceInfo` interface | Research doc | Confirmed: pipeline-detection.ts lines 33-38 | EXACT |
| `lib/dashboard.ts` is NEW | Phase 1 | Confirmed: file does not exist | EXACT |
| `tools/dashboard-tools.ts` is NEW | Phase 2 | Confirmed: file does not exist | EXACT |
| `skills/ralph-status/` is NEW | Phase 2 | Confirmed: directory does not exist among 10 existing skills | EXACT |
| Skill frontmatter pattern | Phase 2 Step 4 | Confirmed against `skills/ralph-setup/SKILL.md`: same structure (description, argument-hint, model, env) | EXACT |

## Warnings

### 1. `list_project_items` Query Does NOT Include `updatedAt`, `closedAt`, or `trackedIssues`

The existing `list_project_items` GraphQL query (project-tools.ts lines 436-493) does NOT fetch `updatedAt`, `closedAt`, or `trackedIssues` in its `... on Issue` content fragment. It fetches only: `number`, `title`, `state`, `url`, `labels`, `assignees`.

The plan says (Phase 2, Step 2, logic flow point 3): "Fetch all project items using same paginated query **pattern** as `list_project_items` -- include `updatedAt`, `closedAt`, `trackedIssues` (blockedBy) in the content fragment."

This correctly implies writing a NEW, expanded GraphQL query rather than reusing the existing one verbatim. The `pick_actionable_issue` tool (issue-tools.ts line 1757) already demonstrates that `trackedIssues(first: 10)` works inside Project V2 item content fragments. And `updatedAt`/`closedAt` are standard Issue fields available in `... on Issue`.

**Not blocking**, but the implementer should understand they are writing a new query, not calling the existing `list_project_items` handler. The plan's Current State Analysis table saying "Reuse for Dashboard: GraphQL query pattern for fetching all items with field values" could be misread as "reuse the query directly." The plan body clarifies this, but the table is misleading.

### 2. `isLocked` Is Derived, Not a Stored Field

The plan's `PhaseSnapshot.issues[].isLocked` field (line 93) is not a field returned by any GraphQL query. It must be derived by checking if the issue's workflow state is in `LOCK_STATES`. This is straightforward but the plan doesn't explicitly state the derivation logic. The implementer should use:

```typescript
isLocked: LOCK_STATES.includes(workflowState)
```

This is consistent with how `pick_actionable_issue` handles lock filtering (issue-tools.ts lines 1803-1807).

### 3. `lock_collision` Detection Does Not Track Lock Ownership

The plan's `lock_collision` health indicator (Phase 1, `detectHealthIssues`) flags "multiple issues in same `LOCK_STATE`" as severity `critical`. This is a reasonable heuristic: since LOCK_STATES represent exclusive ownership (only one agent should be working a locked state at a time), two issues in the same lock state suggests a collision.

However, the current system does not track WHO locked a state. The detection is purely based on issue count per lock state, which is actually sufficient for the stated purpose. The implementer should be aware that this is a "count > 1" check, not an ownership check.

### 4. `blocked` Health Indicator Requires `trackedIssues` Data in Items

The plan's `blocked` health indicator in `detectHealthIssues` checks for "Issue has `blockedBy` with non-Done blocker." This requires the dashboard query to include `trackedIssues` in the content fragment, which the plan does specify in Phase 2 Step 2 point 3. However, the `aggregateByPhase` function (Phase 1) must propagate this data through to the `PhaseSnapshot.issues` array for `detectHealthIssues` to consume it.

The `PhaseSnapshot` interface (lines 82-94) does NOT include a `blockedBy` field on individual issues. The `detectHealthIssues` function therefore cannot detect blocked issues from `PhaseSnapshot` data alone. Either:

(a) Add `blockedBy: Array<{ number: number; state: string }>` to the issue shape in `PhaseSnapshot`, or
(b) Pass the raw items alongside phases to `detectHealthIssues`, or
(c) Have `aggregateByPhase` set a `isBlocked: boolean` flag.

**This is a design gap but not blocking** -- the implementer can choose any approach. Option (a) is cleanest.

### 5. Done Window Filtering Depends on `closedAt`

The plan says `aggregateByPhase` filters Done items to within `doneWindowDays` (default 7). This requires `closedAt` timestamps. The `get_issue` query (issue-tools.ts line 681) confirms `closedAt` is available on GitHub issues. The dashboard's custom query must include it.

There's a subtlety: `closedAt` may be `null` for issues in "Done" workflow state that haven't been closed as GitHub issues (e.g., if workflow state was set manually without closing the issue). The implementer should fall back to `updatedAt` when `closedAt` is null for Done-state issues.

### 6. `assignees` Data Shape

The existing `list_project_items` query does include `assignees(first: 5) { nodes { login } }` in its content fragment (project-tools.ts line 452). The plan's `PhaseSnapshot.issues[].assignees: string[]` expects an array of login strings. The implementer must map `content.assignees.nodes.map(a => a.login)` which is the same pattern already used in `list_project_items` (line 535). No issue here.

### 7. Skill Model Specification

The plan specifies `model: haiku` for the `/ralph-status` skill. The existing `/ralph-setup` skill also uses `model: haiku`. This is consistent and appropriate for a lightweight read-only skill that just calls a tool and displays output.

### 8. `RALPH_COMMAND: "status"` Environment Variable

The plan's skill sets `RALPH_COMMAND: "status"`. The existing skills all set this env var (e.g., `/ralph-setup` sets `RALPH_COMMAND: "setup"`). This appears to be used by hooks for command identification. Consistent with existing patterns.

### 9. Performance: `trackedIssues` in Bulk Query

Adding `trackedIssues(first: 10)` to every item in a paginated project items query adds sub-connections. For 100 items with up to 10 tracked issues each, this adds up to 1000 extra nodes per page. GitHub's GraphQL API has a default node limit of 500,000 per query, so this is well within bounds. The rate limit cost will increase slightly (estimated 2-5 additional points per page) but remains well within the 5000 points/hour budget.

For projects with 200+ issues, consider whether `trackedIssues(first: 5)` would be sufficient to reduce payload size, or make the `trackedIssues` fetch optional (only when `includeHealth` is true).

### 10. `STATE_ORDER` Does Not Include "Canceled" or "Human Needed"

`STATE_ORDER` contains 9 states (Backlog through Done). "Canceled" and "Human Needed" are not in `STATE_ORDER` (they're in `VALID_STATES` but not `STATE_ORDER`). The plan's `aggregateByPhase` must handle these states explicitly -- either appending them after the ordered states or grouping them separately. The plan text says "Groups project items by workflow state using `STATE_ORDER` for ordering" which suggests these two states would be missing from the output.

The implementer should ensure items in "Human Needed" and "Canceled" states appear in the dashboard. The plan's test spec includes "Canceled items grouped separately from Done" and handles "Human Needed" in health detection, but doesn't explicitly say how these states appear in the `phases` array ordering. A reasonable approach: append "Human Needed" and "Canceled" after the STATE_ORDER states.

### 11. Minor: Plan Uses camelCase for Tool Parameters

The plan defines tool parameters in camelCase (`stuckThresholdHours`, `wipLimits`, `doneWindowDays`, `issuesPerPhase`). Existing tools in the codebase also use camelCase for parameters (e.g., `workflowState`, `blockingNumber` in relationship-tools.ts). This is consistent.

## What's Good

- **Pure function architecture**: Extracting all logic into `lib/dashboard.ts` with no I/O is an excellent design. Every function (`aggregateByPhase`, `detectHealthIssues`, `formatMarkdown`, `formatAscii`) is independently testable without mocking.
- **Clear phase structure**: 3 phases with explicit dependencies. Phase 1 (pure logic) -> Phase 2 (tool + formatting + skill) -> Phase 3 (tests). Clean separation.
- **Comprehensive health indicators**: 6 indicator types covering the most important pipeline health signals. The severity levels (info/warning/critical) are well-calibrated.
- **Multiple output formats**: JSON for programmatic consumption, markdown for documentation/PRs, ASCII for terminal display. The `formatted` field approach avoids forcing Claude to render tables.
- **Well-scoped exclusions**: "What We're NOT Doing" clearly rules out web UI, persistent tracking, GitHub Actions, historical trends, and multi-project support.
- **Reuse of existing infrastructure**: Correctly leverages `STATE_ORDER`, `LOCK_STATES`, `TERMINAL_STATES`, `paginateConnection`, `SessionCache`, `FieldOptionCache`, `toolSuccess`/`toolError`.
- **Configurable parameters**: `stuckThresholdHours`, `wipLimits`, `doneWindowDays`, `issuesPerPhase` all have sensible defaults with override capability.
- **Thorough test specification**: Phase 3 lists specific test cases for every function with both positive and negative scenarios (38+ test cases).
- **Performance analysis**: Correctly estimates 5-25 rate limit points, proposes 60-second cache TTL, and `issuesPerPhase` for response size control.
- **First read-only skill**: `/ralph-status` as the first non-mutating skill is a good architectural precedent.

## Summary

The plan is ready for implementation. The warnings are addressable during implementation without replanning:

1. Write a new expanded GraphQL query (don't reuse `list_project_items` verbatim)
2. Derive `isLocked` from `LOCK_STATES.includes(state)`
3. Add `blockedBy` data to the issue shape in `PhaseSnapshot` for the `blocked` health indicator
4. Fall back to `updatedAt` when `closedAt` is null for Done-state issues
5. Handle "Human Needed" and "Canceled" states in the phases array ordering

None of these require structural changes to the plan's architecture. An implementer familiar with the codebase can resolve them inline.
